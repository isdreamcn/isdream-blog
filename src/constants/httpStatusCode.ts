// TODO: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status

// 信息响应( 100- 199)
// 成功响应( 200- 299)
// 重定向消息( 300- 399)
// 客户端错误响应( 400- 499)
// 服务器错误响应( 500- 599)

export enum HttpStatusCode {
  // 此临时响应指示客户端应继续请求或在请求已完成时忽略响应。
  Continue = 100,
  // 此代码是为响应Upgrade来自客户端的请求标头而发送的，并指示服务器正在切换到的协议。
  Switching_Protocols = 101,
  // 此代码表示服务器已收到并正在处理请求，但还没有可用的响应。( WebDAV )
  // Processing = 102,
  // 此状态码主要用于与Link标头一起使用，让用户代理在服务器准备响应时开始预加载资源。
  Early_Hints = 103,
  // 请求成功。“成功”的结果含义取决于 HTTP 方法：
  OK = 200,
  // GET: 资源已被提取并在消息体中传输。
  // HEAD：表示头包含在响应中，没有任何消息正文。
  // PUTor POST：描述动作结果的资源在消息体中传输。
  // TRACE：消息正文包含服务器收到的请求消息。
  // 请求成功，结果创建了一个新资源。这通常是在POST请求或某些PUT请求之后发送的响应。
  Created = 201,
  // 请求已收到，但尚未采取行动。这是不确定的，因为在 HTTP 中无法稍后发送指示请求结果的异步响应。它适用于另一个进程或服务器处理请求或批处理的情况。
  Accepted = 202,
  // 此响应代码表示返回的元数据与源服务器提供的元数据不完全相同，而是从本地或第三方副本收集的。这主要用于另一个资源的镜像或备份。除了该特定情况外，200 OK响应优先于此状态。
  Non_Authoritative_Information = 203,
  // 此请求没有要发送的内容，但标头可能很有用。用户代理可以用新的更新其缓存的资源头。
  No_Content = 204,
  // 告诉用户代理重置发送此请求的文档。
  Reset_Content = 205,
  // Range当从客户端发送标头以仅请求资源的一部分时使用此响应代码。
  Partial_Content = 206,
  // 传达有关多个资源的信息，用于可能适合多个状态代码的情况。( WebDAV )
  // Multi_Status = 207,
  // 在响应元素内部使用<dav:propstat>以避免重复枚举多个绑定的内部成员到同一个集合。( WebDAV )
  // Already_Reported = 208,
  // 服务器已完成GET对资源的请求，响应是应用于当前实例的一个或多个实例操作的结果的表示。（HTTP Delta 编码）
  // IM_Used = 226,
  // 该请求有多个可能的响应。用户代理或用户应该选择其中之一。（没有选择其中一种响应的标准化方式，但建议使用 HTML 链接指向可能性，以便用户选择。）
  Multiple_Choices = 300,
  // 请求资源的 URL 已永久更改。新的 URL 在响应中给出。
  Moved_Permanently = 301,
  // 此响应码表示请求资源的 URI 已临时更改。将来可能会对 URI 进行进一步的更改。因此，客户端在以后的请求中应该使用相同的 URI。
  Found = 302,
  // 服务器发送此响应以指示客户端使用 GET 请求从另一个 URI 获取请求的资源。
  See_Other = 303,
  // 这用于缓存目的。它告诉客户端响应没有被修改，因此客户端可以继续使用相同的缓存版本的响应。
  Not_Modified = 304,
  // 在以前版本的 HTTP 规范中定义，表示请求的响应必须由代理访问。由于与代理的带内配置有关的安全问题，它已被弃用。
  // Use_Proxy = 305,
  // 此响应码不再使用；它只是保留。它用于以前版本的 HTTP/1.1 规范。
  // Unused = 306,
  // 服务器发送此响应以指示客户端使用先前请求中使用的相同方法从另一个 URI 获取请求的资源。这与 HTTP 响应代码具有相同的语义302 Found，但用户代理不得更改使用的 HTTP 方法：如果POST在第一个请求中使用了 a，则POST必须在第二个请求中使用 a。
  Temporary_Redirect = 307,
  // 这意味着资源现在永久位于另一个 URI，由Location:HTTP 响应标头指定。这与 HTTP 响应代码具有相同的语义301 Moved Permanently，但用户代理不得更改使用的 HTTP 方法：如果POST在第一个请求中使用了 a，则POST必须在第二个请求中使用 a。
  Permanent_Redirect = 308,
  // 由于某些被认为是客户端错误（例如，格式错误的请求语法、无效的请求消息帧或欺骗性请求路由），服务器不能或不会处理请求。
  Bad_Request = 400,
  // 尽管 HTTP 标准指定“未经授权”，但从语义上讲，此响应意味着“未经身份验证”。也就是说，客户端必须对自己进行身份验证才能获得请求的响应。
  Unauthorized = 401,
  // 此响应代码保留供将来使用。创建此代码的最初目的是将其用于数字支付系统，但是此状态代码很少使用，并且不存在标准约定。
  // paymentRequired = 402,
  // 客户无权访问内容；也就是说，它是未经授权的，因此服务器拒绝提供所请求的资源。与 不同401 Unauthorized的是，客户端的身份是服务器已知的。
  Forbidden = 403,
  // 服务器找不到请求的资源。在浏览器中，这意味着无法识别 URL。在 API 中，这也可能意味着端点有效但资源本身不存在。服务器也可以发送此响应，而不是403 Forbidden向未经授权的客户端隐藏资源的存在。此响应代码可能是最广为人知的，因为它在网络上频繁出现。
  Not_Found = 404,
  // 请求方法是服务器已知的，但目标资源不支持。例如，API 可能不允许调用DELETE来删除资源。
  Method_Not_Allowed = 405,
  // 当 Web 服务器在执行服务器驱动的内容协商后，没有找到任何符合用户代理给定标准的内容时，将发送此响应。
  Not_Acceptable = 406,
  // 这类似于401 Unauthorized但需要由代理完成身份验证。
  Proxy_Authentication_Required = 407,
  // 某些服务器在空闲连接上发送此响应，即使客户端之前没有任何请求。这意味着服务器想要关闭这个未使用的连接。由于某些浏览器（例如 Chrome、Firefox 27+ 或 IE9）使用 HTTP 预连接机制来加快冲浪速度，因此这种响应的使用率更高。另请注意，某些服务器仅关闭连接而不发送此消息。
  Request_Timeout = 408,
  // 当请求与服务器的当前状态冲突时发送此响应。
  Conflict = 409,
  // 当请求的内容已从服务器中永久删除且没有转发地址时，将发送此响应。客户应该删除他们的缓存和资源链接。HTTP 规范打算将此状态代码用于“限时促销服务”。API 不应该强制使用此状态代码来指示已删除的资源。
  Gone = 410,
  // 服务器拒绝了请求，因为Content-Length未定义标头字段并且服务器需要它。
  Length_Required = 411,
  // 客户端在其标头中指出了服务器不满足的先决条件。
  Precondition_Failed = 412,
  // 请求实体大于服务器定义的限制。服务器可能会关闭连接或返回Retry-After标头字段。
  Payload_TooLarge = 413,
  // 客户端请求的 URI 比服务器愿意解释的要长。
  URI_Too_Long = 414,
  // 服务器不支持请求数据的媒体格式，因此服务器拒绝请求。
  Unsupported_Media_Type = 415,
  // Range无法满足请求中头字段 指定的范围。该范围可能超出目标 URI 数据的大小。
  Range_Not_Satisfiable = 416,
  // 这个响应码意味着Expect服务器不能满足请求头域所指示的期望。
  Expectation_Failed = 417,
  // 服务器拒绝尝试用茶壶冲泡咖啡。
  Im_A_Teapot = 418,
  // 该请求被定向到无法产生响应的服务器。这可以由未配置为针对请求 URI 中包含的方案和权限组合生成响应的服务器发送。
  // Misdirected_Request = 421,
  // 该请求格式正确，但由于语义错误而无法执行。( WebDAV )
  Unprocessable_Entity = 422,
  // 正在访问的资源被锁定。( WebDAV )
  // Locked = 423,
  // 由于先前的请求失败，请求失败。( WebDAV )
  // Failed_Dependency = 424,
  // 表示服务器不愿意冒险处理可能被重放的请求。实验性的
  // Too_Early = 425,
  // 服务器拒绝使用当前协议执行请求，但在客户端升级到不同协议后可能愿意这样做。服务器在 426 响应中发送Upgrade标头以指示所需的协议。
  Upgrade_Required = 426,
  // 源服务器要求请求是有条件的。此响应旨在防止“丢失更新”问题，其中客户端GETsa 资源的状态，修改它并将PUT其发送回服务器，同时第三方已修改服务器上的状态，导致冲突。
  Precondition_Required = 428,
  // 用户在给定时间内发送了太多请求（“速率限制”）。
  Too_Many_Requests = 429,
  // 服务器不愿意处理请求，因为它的头字段太大。减少请求头字段的大小后，可以重新提交请求。
  Request_Header_Fields_Too_Large = 431,
  // 用户代理请求了无法合法提供的资源，例如被政府审查的网页。
  Unavailable_ForLegal_Reasons = 451,
  // 服务器遇到了不知道如何处理的情况。
  Internal_Server_Error = 500,
  // 服务器不支持请求方式，无法处理。服务器需要支持的唯一方法（因此不能返回此代码）是GET和HEAD.
  Not_Implemented = 501,
  // 此错误响应意味着服务器在作为网关工作以获取处理请求所需的响应时，得到了无效响应。
  Bad_Gateway = 502,
  // 服务器尚未准备好处理请求。常见原因是服务器因维护而停机或过载。请注意，与此响应一起，应发送解释问题的用户友好页面。此响应应用于临时条件，并且Retry-AfterHTTP 标头应尽可能包含恢复服务之前的估计时间。网站管理员还必须注意与此响应一起发送的与缓存相关的标头，因为这些临时条件响应通常不应该被缓存。
  Service_Unavailable = 503,
  // 当服务器作为网关无法及时得到响应时，会给出这个错误响应。
  Gateway_Timeout = 504,
  // 服务器不支持请求中使用的 HTTP 版本。
  HTTP_Version_Not_Supported = 505,
  // 服务器有一个内部配置错误：选择的变体资源被配置为自己参与透明内容协商，因此不是协商过程中的适当端点。
  Variant_Also_Negotiates = 506,
  // 无法对资源执行该方法，因为服务器无法存储成功完成请求所需的表示。( WebDAV )
  Insufficient_Storage = 507,
  // 服务器在处理请求时检测到无限循环。( WebDAV )
  Loop_Detected = 508,
  // 服务器需要对请求进行进一步扩展才能完成它。
  Not_Extended = 510,
  // 表示客户端需要进行身份验证才能获得网络访问权限。
  Network_Authentication_Required = 511
}

export default HttpStatusCode
